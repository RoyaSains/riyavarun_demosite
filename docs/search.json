[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Authors",
    "section": "",
    "text": "This project is the collaborative effort of two Master of City Planning students specializing in Sustainable Transportation and Infrastructure Planning. Driven by a commitment to creating people-centered transit solutions, the authors bring a data-driven and equity-focused approach to addressing pressing urban mobility challenges\n\n\n\nRiya Saini\n(She/ Her)\nMaster of City Planning Student | Sustainable Transportation & Infrastructure Planning\nRiya Saini is a Master of City Planning student at UPenn with a focus on urban mobility. She is passionate about transportation accessibility and the impact of transit on public health. Riya has experience in transportation modeling, trip generation mode choice modeling, and generating visually stunning graphs analyzing transit and vehicle accessibility across the US.\n\n\n\n\n\nVarun Bhakhri\n(He/ Him)\nMaster of City Planning Student | Sustainable Transportation & Infrastructure Planning\nRiya Saini is a Master of City Planning student at UPenn with a focus on urban mobility. She is passionate about transportation accessibility and the impact of transit on public health. Riya has experience in transportation modeling, trip generation mode choice modeling, and generating visually stunning graphs analyzing transit and vehicle accessibility across the US."
  },
  {
    "objectID": "social_vulnerability.html",
    "href": "social_vulnerability.html",
    "title": "Transit Vulnerability",
    "section": "",
    "text": "In order to address disparities in transportation access and prioritize vulnerable communities, we developed a Transit Vulnerability Index (TVI) for Philadelphia. This index integrates a variety of demographic, transit accessibility, and environmental factors to identify areas most in need of impactful transit interventions. Inspired by existing methodologies, such as the work by Duan et al. (2016), our TVI emphasizes factors such as median income, racial demographics, workforce commuting patterns, access to vehicles, and mode choice. Additionally, we incorporate the mean travel time to work, which directly impacts daily commute times, and the city’s heat vulnerability index, which identifies areas at risk during extreme heat events.\nDrawing from the findings in Duan et al. (2016), the TVI recognizes that vulnerability is not solely about exposure to transportation challenges but is also shaped by social and environmental factors, such as income inequality and heat stress, which exacerbate the mobility challenges faced by disadvantaged populations. We focus on these factors at the census tract level.\nNote: we opted to not go lower than census tract level to reduce margins of error in our result.\n\n\n\n\nCode\nimport os\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport geopandas as gpd\nimport cenpy as cny\nimport pygris\nfrom pygris import tracts\nimport numpy as np\nimport altair as alt\nimport seaborn as sns\nimport shapely\nfrom shapely.geometry import Point\n\n\n\n\nCode\n# Establish connection to the API\nacs = cny.remote.APIConnection(\"ACSDT5Y2023\")\n\n# Define variables and query data for Philadelphia County\nvariables = [\n    \"B19013_001E\",  # Median household income in the past 12 months\n    \"B01003_001E\",  # Total population\n    \"B11001_001E\",  # Total households\n    \"B08006_001E\",  # Total workers (commuting population)    \n    \"B02001_002E\",  # White alone\n    \"B02001_003E\",  # Black or African American alone\n    \"B08013_001E\",  # Mean travel time to work\n    \"B08201_002E\",  # No vehicles available\n    \"B08201_003E\",  # 1 vehicle available\n    \"B08201_004E\",  # 2 vehicles available\n    \"B08201_005E\",  # 3 vehicles available\n    \"B08201_006E\",  # 4 or more vehicles available\n    \"B08006_002E\",  # Car, truck, or van – drove alone\n    \"B08006_003E\",  # Car, truck, or van – carpooled\n    \"B08006_008E\",  # Public transportation (excluding taxicab)\n    \"B08006_015E\",  # Walked\n    \"B08006_017E\",  # Bicycle\n    \"B08006_018E\"   # Worked at home\n]\n\n# Query data\nacs_data = acs.query(\n    variables,\n    geo_unit=\"tract\",\n    geo_filter={\"state\": \"42\", \"county\": \"101\"})\n\n# Format GEOID\nacs_data['GEOID'] = (\n    acs_data['state'] +\n    acs_data['county'] +\n    acs_data['tract'])\n\n# Rename columns \nacs_data = acs_data.rename(columns={\n    'B19013_001E': 'Median_Income',\n    'B01003_001E': 'Total_Population',\n    'B11001_001E': 'Total_households',\n    'B08006_001E': 'Total_Workers',\n    'B02001_002E': 'White_Alone',\n    'B02001_003E': 'Black_Alone',\n    'B08013_001E': 'Mean_travel_time',\n    'B08201_002E': 'No_vehicles',\n    'B08201_003E': 'One_vehicle',\n    'B08201_004E': 'Two_vehicles',\n    'B08201_005E': 'Three_vehicles',\n    'B08201_006E': 'Four_or_more_vehicles',\n    'B08006_002E': 'Drove_Alone',\n    'B08006_003E': 'Carpooled',\n    'B08006_008E': 'Public_Transportation',\n    'B08006_015E': 'Walked',\n    'B08006_017E': 'Bicycle',\n    'B08006_018E': 'Worked_at_Home'})\n\n# Drop  columns\nacs_data = acs_data.drop(columns=['state', 'county','tract'])\n\n# Downloading census tract geometries for Philadelphia County\nphila_tracts = tracts(state=\"42\", county=\"101\", cb=True, year=2023)\n\n# Merge ACS data with geometries on GEOID\nacs_data = phila_tracts.merge(acs_data, on=\"GEOID\", how=\"left\")\n\n# Drop columns\nacs_data = acs_data[['GEOID', 'geometry', 'Median_Income', 'Total_Population', 'Total_households', 'Total_Workers',\n       'White_Alone', 'Black_Alone', 'Mean_travel_time', 'No_vehicles', 'One_vehicle', 'Two_vehicles', \n       'Three_vehicles', 'Four_or_more_vehicles', 'Drove_Alone', 'Carpooled',\n       'Public_Transportation', 'Walked', 'Bicycle', 'Worked_at_Home']]\n\nacs_data.head\n\n\n&lt;bound method NDFrame.head of            GEOID                                           geometry  \\\n0    42101001500  POLYGON ((-75.16558 39.94366, -75.16021 39.943...   \n1    42101001800  POLYGON ((-75.16620 39.94081, -75.16599 39.941...   \n2    42101002802  POLYGON ((-75.16735 39.92658, -75.16350 39.929...   \n3    42101004001  POLYGON ((-75.17002 39.92314, -75.16974 39.924...   \n4    42101006300  POLYGON ((-75.24686 39.91876, -75.23967 39.923...   \n..           ...                                                ...   \n403  42101000500  POLYGON ((-75.16506 39.95361, -75.16332 39.953...   \n404  42101027100  POLYGON ((-75.12749 40.05022, -75.12714 40.051...   \n405  42101000200  POLYGON ((-75.16269 39.95623, -75.16234 39.957...   \n406  42101013200  POLYGON ((-75.16096 39.96447, -75.16080 39.965...   \n407  42101032100  POLYGON ((-75.06511 40.01751, -75.06113 40.019...   \n\n    Median_Income Total_Population Total_households Total_Workers White_Alone  \\\n0          108378             3027             1486          1978        2213   \n1          121719             3285             1700          2289        2425   \n2           94427             5868             2432          3148        3525   \n3           82258             4118             2105          2662        3165   \n4           32997             4380             1696          1776          99   \n..            ...              ...              ...           ...         ...   \n403         68977             3292             1480          1591        1351   \n404         60255             2638             1053          1059         157   \n405         97256             3259             1742          1737        1490   \n406         44299             3450             1752          1584        1077   \n407         50409             3686             1629          1766        1466   \n\n    Black_Alone Mean_travel_time No_vehicles One_vehicle Two_vehicles  \\\n0           466            41280         570         758          119   \n1           443            46780         354        1098          165   \n2           319            60580         439        1545          422   \n3           135            70965         465        1112          498   \n4          3667            54680         652         799          133   \n..          ...              ...         ...         ...          ...   \n403        1105            30435        1031         396           53   \n404        1832            38785         165         411          433   \n405         264            31870         452        1108          155   \n406        1563            38195         793         655          252   \n407         757            49210         349        1066          148   \n\n    Three_vehicles Four_or_more_vehicles Drove_Alone Carpooled  \\\n0                5                    34         488       468   \n1               42                    41         716       687   \n2               26                     0        1199      1001   \n3               11                    19        1033       873   \n4               85                    27        1067      1001   \n..             ...                   ...         ...       ...   \n403              0                     0         314       314   \n404             35                     9         699       626   \n405              0                    27         404       283   \n406             52                     0         579       559   \n407             33                    33        1419      1103   \n\n    Public_Transportation Walked Bicycle Worked_at_Home  \n0                     372    377     565            982  \n1                     101    617     690            983  \n2                     618    253     857           1855  \n3                     743    193     483           1291  \n4                     586     84      29            751  \n..                    ...    ...     ...            ...  \n403                   454    444     359            721  \n404                   269      0      80            481  \n405                   249    503     549           1081  \n406                   461    193     328            529  \n407                   221     68      43            842  \n\n[408 rows x 20 columns]&gt;\n\n\n\n\n\nBased on the following maps and bar chart, We know that most workers in Philadelphia commute to work by car. The share of workers who take transit is significantly lower with the exception of North Philadelphia (Strawberry Mansion, Brewerytown). As we will see below, these neighborhoods also have some of the lowest median incomes in Philadelphia. The lack of capital often reduces such users to dependent riders, who will travel by transit regardless of the level of service. However, such riders are also worthy of improved level of service.\n\n\nCode\n# List of columns to plot\ncolumns_to_plot = ['Drove_Alone', 'Carpooled', 'Public_Transportation', 'Walked', 'Bicycle', 'Worked_at_Home']\nacs_data_melted = acs_data.melt(id_vars=['GEOID'], value_vars=columns_to_plot, \n                                var_name='Mode of Transportation', value_name='Count')\n\nbrush = alt.selection_interval()\n\n# Map1: Car use to work\nmap_plot = alt.Chart(acs_data).mark_geoshape().encode(\n    color=alt.Color('Drove_Alone:Q', scale=alt.Scale(scheme='blues')),\n    tooltip=['Drove_Alone:Q', 'Carpooled:Q', 'Public_Transportation:Q', 'Walked:Q', 'Bicycle:Q', 'Worked_at_Home:Q']\n).add_params(brush).properties(\n    width=300,\n    height=500,\n    title=\"Drove Alone to Work\")\n\n# Map2: Public Transportation use to work\nmap_plot1 = alt.Chart(acs_data).mark_geoshape().encode(\n    color=alt.Color('Public_Transportation:Q', scale=alt.Scale(scheme='reds')),\n    tooltip=['Drove_Alone:Q', 'Carpooled:Q', 'Public_Transportation:Q', 'Walked:Q', 'Bicycle:Q', 'Worked_at_Home:Q']\n).add_params(brush).properties(\n    width=300,\n    height=500,\n    title=\"Public Transportation to Work\")\n\n# Map3: Total mode of transportation\nbars = alt.Chart(acs_data_melted).mark_bar().encode(\n    x=alt.X('sum(Count):Q', title=\"Total Number of Workers by Mode of Transportation\"),\n    y=alt.Y('Mode of Transportation:N', title=\"Mode of Transportation\"),\n    color='Mode of Transportation:N'\n).transform_filter(\n    brush\n).properties(width=300)\n\n# Combine the maps\nchart = alt.vconcat(\n    alt.hconcat(map_plot, map_plot1), bars)\n\nchart\n\n\n\n\n\n\n\n\n\n\n\nFor our analysis, we aimed to examine key indicators that could influence a commuter’s mode choice. We first compared the total population and total number of workers in each census tract to identify where work-based trips are most likely to be generated. The two graphs show a strong correlation, indicating that areas with larger populations also tend to have a higher number of workers.\nIn 2023, the median household income in Philadelphia was $60,698, adjusted for inflation. However, when visualizing the data on the map, income disparities become apparent. High-income areas are concentrated in the Northwest and South, while the West, North, and Northeast regions fall below the median income threshold, highlighting areas of economic inequality.\nWe explored travel time across different census tracts to identify areas with greater mobility challenges. As expected, regions farther from Center City experience longer travel times. However, it is noteworthy that travel times for residents in North Philly and Lower West Philly are higher than those in other nearby areas, despite their proximity to the city center.\nOur map also reveals several key correlations. Areas with a majority of Black households tend to have a higher proportion of households without vehicles. Additionally, these areas generally exhibit lower median incomes, further indicating socioeconomic disparities that influence transportation needs and mode choice across the city.\n\n\nCode\n# Convert object columns to numeric, coercing errors into NaN (missing data)\ncols_to_convert = ['Median_Income', 'Total_Population', 'Total_Workers', 'White_Alone', 'Black_Alone',\n                   'Mean_travel_time', 'No_vehicles', 'One_vehicle', 'Two_vehicles', \n                   'Three_vehicles', 'Four_or_more_vehicles']\n\nfor col in cols_to_convert:\n    acs_data[col] = pd.to_numeric(acs_data[col], errors='coerce')\n    \n# Calculate the share of each race relative to the total population\nacs_data['White_Share'] = acs_data['White_Alone'] / acs_data['Total_Population']\nacs_data['Black_Share'] = acs_data['Black_Alone'] / acs_data['Total_Population']\n\n# Assign the race with the highest share\nacs_data['race_majority'] = acs_data[['White_Share', 'Black_Share']].idxmax(axis=1)\n\n# Clean data\nacs_data = acs_data[acs_data['Median_Income'] != -666666666]\n\n# Calculate Mean travel time in minutes\nacs_data['Average_travel_time'] = (acs_data['Mean_travel_time'] / acs_data['Total_Workers']).fillna(0).apply(lambda x: max(x, 0))\nacs_data['Average_travel_time'] = acs_data['Average_travel_time'].round(0).astype(int)\n\n\nC:\\Users\\USER\\miniforge3\\envs\\musa-550-fall-2023\\lib\\site-packages\\geopandas\\geodataframe.py:1538: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n\n\n\n\nCode\n# Create a list of the columns to plot\ncolumns_to_plot = ['Total_Population', 'Total_Workers', 'Median_Income','Average_travel_time', 'No_vehicles', 'race_majority']\n\n# Set up a grid of subplots\nfig, axes = plt.subplots(3, 2, figsize=(8, 6)) \naxes = axes.flatten() \n\n# Loop through the columns to plot each one\nfor i, column in enumerate(columns_to_plot):\n    ax = axes[i]\n    acs_data.plot(column=column, ax=ax, legend=True, cmap='Blues')\n    ax.set_title(f\"{column}\")\n    ax.set_axis_off()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nWhile researching a transit rider vulnerability matrix, we consistently found that exposure to heat was a critical factor. However, vulnerability to heat is closely correlated with several other variables, many of which we have already explored. As a result, we decided to incorporate the City’s Heat Vulnerability Index (HVI) to highlight areas most at risk of experiencing heat-related illness.\nThe Philadelphia Heat Vulnerability Index (HVI) captures key factors that contribute to the negative health effects of extreme heat events. The HVI rating is calculated by combining both exposure and sensitivity indicators:\n\nAge: The percentage of the population over 65 years old, as older individuals are more susceptible to heat-related illnesses.\nEducational Attainment: The percentage of individuals over 25 years old without a high school diploma, which can be linked to lower awareness of heat risks.\nLanguage Barrier: The percentage of limited English-speaking households, which can affect the ability to receive heat-related warnings and information.\nLow Socioeconomic Status: The percentage of the population living below the Federal Poverty Level, as economically disadvantaged individuals may have fewer resources to adapt to extreme heat.\nRace & Ethnicity: The percentage of the population identifying as non-white, as certain racial and ethnic groups may experience heightened vulnerability due to social and economic factors.\nSocial Isolation: The percentage of the population over 65 years old living alone, as socially isolated individuals may lack support during heat events.\nHealth Status: This factor considers the underlying health conditions that may exacerbate the effects of extreme heat, such as chronic diseases or disabilities that limit mobility or access to cooling resources.\n\n\n\nCode\nheat = pd.read_csv('data\\heat_vulnerability_ct.csv')\nheat.rename(columns={'geoid10': 'GEOID'}, inplace=True)\n\n# Merge the heat vulnerability data with acs data\nheat['GEOID'] = heat['GEOID'].astype(str)\nacs_data_index = acs_data.merge(heat, on='GEOID')\n\n# List of the columns to plot\ncolumns_to_plot = ['hsi_score','hei_score', 'hvi_score', 'n_veryhigh']\n\nfig, axes = plt.subplots(2, 2, figsize=(8, 6))\naxes = axes.flatten() \n\n# Loop through the columns and plot each one\nfor i, column in enumerate(columns_to_plot):\n    ax = axes[i]\n    acs_data_index.plot(column=column, ax=ax, legend=True, cmap='Blues')\n    ax.set_title(f\"{column}\")\n    ax.set_axis_off()  \nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nThe City’s Heat Vulnerability Index (HVI) incorporates several socio-demographic parameters to assess vulnerability, and for our Transit Vulnerability Index (TVI), we have integrated these factors with transit-specific parameters, such as travel time and lack of available household vehicles. However, by focusing solely on these three factors, we may overlook households that, although located far from transit routes and reliant on personal vehicles for commuting, still experience economic disadvantage. To address this gap, we reintroduced the income variable to better account for such populations.\nGiven that this assessment is focused primarily on transit, we assigned a value of 1 to both median income and HVI, and a value of 2 to commute time and access to vehicles, reflecting their relative importance in influencing transit vulnerability. Our final TVI, ranging from 0 to 6, provides a comprehensive vulnerability score for census tracts across Philadelphia. Notably, the map below highlights North Philadelphia, particularly Strawberry Mansion, and West Philadelphia, specifically Cobbs Creek, as areas where transit riders are particularly vulnerable.\n\n\nCode\n# Social Vulnerability Index (SVI)\n\nhighest_quartile_travel_time = acs_data_index['Average_travel_time'].quantile(0.75)\nhighest_quartile_no_vehicles = acs_data_index['No_vehicles'].quantile(0.75)\nlowest_quartile_median_income = acs_data_index['Median_Income'].quantile(0.25)\n\nacs_data_index['Social_Vulnerability_Index'] = 0\n\n# Assign points\nacs_data_index.loc[acs_data_index['n_veryhigh'] == 1, 'Social_Vulnerability_Index'] += 1\nacs_data_index.loc[acs_data_index['Median_Income'] &lt;= lowest_quartile_median_income, 'Social_Vulnerability_Index'] += 1\nacs_data_index.loc[acs_data_index['Average_travel_time'] &gt;= highest_quartile_travel_time, 'Social_Vulnerability_Index'] += 2\nacs_data_index.loc[acs_data_index['No_vehicles'] &gt;= highest_quartile_no_vehicles, 'Social_Vulnerability_Index'] += 2\nacs_data_index[['n_veryhigh', 'Average_travel_time', 'No_vehicles', 'Median_Income','Social_Vulnerability_Index']].head()\n\n# Create the first map plot (Choropleth map)\nmap_plot = alt.Chart(acs_data_index).mark_geoshape().encode(\n    color=alt.Color('Social_Vulnerability_Index:Q', scale=alt.Scale(scheme='blues')),\n    tooltip=['GEOID:N', 'n_veryhigh:Q', 'Average_travel_time:Q', 'No_vehicles:Q', 'Median_Income:Q','race_majority:N']\n).add_params(brush).properties(\n    width=500,\n    height=500)\n\nchart = alt.vconcat(map_plot)\nchart"
  },
  {
    "objectID": "social_vulnerability.html#transit-vulnerability-index",
    "href": "social_vulnerability.html#transit-vulnerability-index",
    "title": "Transit Vulnerability",
    "section": "",
    "text": "In order to address disparities in transportation access and prioritize vulnerable communities, we developed a Transit Vulnerability Index (TVI) for Philadelphia. This index integrates a variety of demographic, transit accessibility, and environmental factors to identify areas most in need of impactful transit interventions. Inspired by existing methodologies, such as the work by Duan et al. (2016), our TVI emphasizes factors such as median income, racial demographics, workforce commuting patterns, access to vehicles, and mode choice. Additionally, we incorporate the mean travel time to work, which directly impacts daily commute times, and the city’s heat vulnerability index, which identifies areas at risk during extreme heat events.\nDrawing from the findings in Duan et al. (2016), the TVI recognizes that vulnerability is not solely about exposure to transportation challenges but is also shaped by social and environmental factors, such as income inequality and heat stress, which exacerbate the mobility challenges faced by disadvantaged populations. We focus on these factors at the census tract level.\nNote: we opted to not go lower than census tract level to reduce margins of error in our result.\n\n\n\n\nCode\nimport os\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport geopandas as gpd\nimport cenpy as cny\nimport pygris\nfrom pygris import tracts\nimport numpy as np\nimport altair as alt\nimport seaborn as sns\nimport shapely\nfrom shapely.geometry import Point\n\n\n\n\nCode\n# Establish connection to the API\nacs = cny.remote.APIConnection(\"ACSDT5Y2023\")\n\n# Define variables and query data for Philadelphia County\nvariables = [\n    \"B19013_001E\",  # Median household income in the past 12 months\n    \"B01003_001E\",  # Total population\n    \"B11001_001E\",  # Total households\n    \"B08006_001E\",  # Total workers (commuting population)    \n    \"B02001_002E\",  # White alone\n    \"B02001_003E\",  # Black or African American alone\n    \"B08013_001E\",  # Mean travel time to work\n    \"B08201_002E\",  # No vehicles available\n    \"B08201_003E\",  # 1 vehicle available\n    \"B08201_004E\",  # 2 vehicles available\n    \"B08201_005E\",  # 3 vehicles available\n    \"B08201_006E\",  # 4 or more vehicles available\n    \"B08006_002E\",  # Car, truck, or van – drove alone\n    \"B08006_003E\",  # Car, truck, or van – carpooled\n    \"B08006_008E\",  # Public transportation (excluding taxicab)\n    \"B08006_015E\",  # Walked\n    \"B08006_017E\",  # Bicycle\n    \"B08006_018E\"   # Worked at home\n]\n\n# Query data\nacs_data = acs.query(\n    variables,\n    geo_unit=\"tract\",\n    geo_filter={\"state\": \"42\", \"county\": \"101\"})\n\n# Format GEOID\nacs_data['GEOID'] = (\n    acs_data['state'] +\n    acs_data['county'] +\n    acs_data['tract'])\n\n# Rename columns \nacs_data = acs_data.rename(columns={\n    'B19013_001E': 'Median_Income',\n    'B01003_001E': 'Total_Population',\n    'B11001_001E': 'Total_households',\n    'B08006_001E': 'Total_Workers',\n    'B02001_002E': 'White_Alone',\n    'B02001_003E': 'Black_Alone',\n    'B08013_001E': 'Mean_travel_time',\n    'B08201_002E': 'No_vehicles',\n    'B08201_003E': 'One_vehicle',\n    'B08201_004E': 'Two_vehicles',\n    'B08201_005E': 'Three_vehicles',\n    'B08201_006E': 'Four_or_more_vehicles',\n    'B08006_002E': 'Drove_Alone',\n    'B08006_003E': 'Carpooled',\n    'B08006_008E': 'Public_Transportation',\n    'B08006_015E': 'Walked',\n    'B08006_017E': 'Bicycle',\n    'B08006_018E': 'Worked_at_Home'})\n\n# Drop  columns\nacs_data = acs_data.drop(columns=['state', 'county','tract'])\n\n# Downloading census tract geometries for Philadelphia County\nphila_tracts = tracts(state=\"42\", county=\"101\", cb=True, year=2023)\n\n# Merge ACS data with geometries on GEOID\nacs_data = phila_tracts.merge(acs_data, on=\"GEOID\", how=\"left\")\n\n# Drop columns\nacs_data = acs_data[['GEOID', 'geometry', 'Median_Income', 'Total_Population', 'Total_households', 'Total_Workers',\n       'White_Alone', 'Black_Alone', 'Mean_travel_time', 'No_vehicles', 'One_vehicle', 'Two_vehicles', \n       'Three_vehicles', 'Four_or_more_vehicles', 'Drove_Alone', 'Carpooled',\n       'Public_Transportation', 'Walked', 'Bicycle', 'Worked_at_Home']]\n\nacs_data.head\n\n\n&lt;bound method NDFrame.head of            GEOID                                           geometry  \\\n0    42101001500  POLYGON ((-75.16558 39.94366, -75.16021 39.943...   \n1    42101001800  POLYGON ((-75.16620 39.94081, -75.16599 39.941...   \n2    42101002802  POLYGON ((-75.16735 39.92658, -75.16350 39.929...   \n3    42101004001  POLYGON ((-75.17002 39.92314, -75.16974 39.924...   \n4    42101006300  POLYGON ((-75.24686 39.91876, -75.23967 39.923...   \n..           ...                                                ...   \n403  42101000500  POLYGON ((-75.16506 39.95361, -75.16332 39.953...   \n404  42101027100  POLYGON ((-75.12749 40.05022, -75.12714 40.051...   \n405  42101000200  POLYGON ((-75.16269 39.95623, -75.16234 39.957...   \n406  42101013200  POLYGON ((-75.16096 39.96447, -75.16080 39.965...   \n407  42101032100  POLYGON ((-75.06511 40.01751, -75.06113 40.019...   \n\n    Median_Income Total_Population Total_households Total_Workers White_Alone  \\\n0          108378             3027             1486          1978        2213   \n1          121719             3285             1700          2289        2425   \n2           94427             5868             2432          3148        3525   \n3           82258             4118             2105          2662        3165   \n4           32997             4380             1696          1776          99   \n..            ...              ...              ...           ...         ...   \n403         68977             3292             1480          1591        1351   \n404         60255             2638             1053          1059         157   \n405         97256             3259             1742          1737        1490   \n406         44299             3450             1752          1584        1077   \n407         50409             3686             1629          1766        1466   \n\n    Black_Alone Mean_travel_time No_vehicles One_vehicle Two_vehicles  \\\n0           466            41280         570         758          119   \n1           443            46780         354        1098          165   \n2           319            60580         439        1545          422   \n3           135            70965         465        1112          498   \n4          3667            54680         652         799          133   \n..          ...              ...         ...         ...          ...   \n403        1105            30435        1031         396           53   \n404        1832            38785         165         411          433   \n405         264            31870         452        1108          155   \n406        1563            38195         793         655          252   \n407         757            49210         349        1066          148   \n\n    Three_vehicles Four_or_more_vehicles Drove_Alone Carpooled  \\\n0                5                    34         488       468   \n1               42                    41         716       687   \n2               26                     0        1199      1001   \n3               11                    19        1033       873   \n4               85                    27        1067      1001   \n..             ...                   ...         ...       ...   \n403              0                     0         314       314   \n404             35                     9         699       626   \n405              0                    27         404       283   \n406             52                     0         579       559   \n407             33                    33        1419      1103   \n\n    Public_Transportation Walked Bicycle Worked_at_Home  \n0                     372    377     565            982  \n1                     101    617     690            983  \n2                     618    253     857           1855  \n3                     743    193     483           1291  \n4                     586     84      29            751  \n..                    ...    ...     ...            ...  \n403                   454    444     359            721  \n404                   269      0      80            481  \n405                   249    503     549           1081  \n406                   461    193     328            529  \n407                   221     68      43            842  \n\n[408 rows x 20 columns]&gt;\n\n\n\n\n\nBased on the following maps and bar chart, We know that most workers in Philadelphia commute to work by car. The share of workers who take transit is significantly lower with the exception of North Philadelphia (Strawberry Mansion, Brewerytown). As we will see below, these neighborhoods also have some of the lowest median incomes in Philadelphia. The lack of capital often reduces such users to dependent riders, who will travel by transit regardless of the level of service. However, such riders are also worthy of improved level of service.\n\n\nCode\n# List of columns to plot\ncolumns_to_plot = ['Drove_Alone', 'Carpooled', 'Public_Transportation', 'Walked', 'Bicycle', 'Worked_at_Home']\nacs_data_melted = acs_data.melt(id_vars=['GEOID'], value_vars=columns_to_plot, \n                                var_name='Mode of Transportation', value_name='Count')\n\nbrush = alt.selection_interval()\n\n# Map1: Car use to work\nmap_plot = alt.Chart(acs_data).mark_geoshape().encode(\n    color=alt.Color('Drove_Alone:Q', scale=alt.Scale(scheme='blues')),\n    tooltip=['Drove_Alone:Q', 'Carpooled:Q', 'Public_Transportation:Q', 'Walked:Q', 'Bicycle:Q', 'Worked_at_Home:Q']\n).add_params(brush).properties(\n    width=300,\n    height=500,\n    title=\"Drove Alone to Work\")\n\n# Map2: Public Transportation use to work\nmap_plot1 = alt.Chart(acs_data).mark_geoshape().encode(\n    color=alt.Color('Public_Transportation:Q', scale=alt.Scale(scheme='reds')),\n    tooltip=['Drove_Alone:Q', 'Carpooled:Q', 'Public_Transportation:Q', 'Walked:Q', 'Bicycle:Q', 'Worked_at_Home:Q']\n).add_params(brush).properties(\n    width=300,\n    height=500,\n    title=\"Public Transportation to Work\")\n\n# Map3: Total mode of transportation\nbars = alt.Chart(acs_data_melted).mark_bar().encode(\n    x=alt.X('sum(Count):Q', title=\"Total Number of Workers by Mode of Transportation\"),\n    y=alt.Y('Mode of Transportation:N', title=\"Mode of Transportation\"),\n    color='Mode of Transportation:N'\n).transform_filter(\n    brush\n).properties(width=300)\n\n# Combine the maps\nchart = alt.vconcat(\n    alt.hconcat(map_plot, map_plot1), bars)\n\nchart\n\n\n\n\n\n\n\n\n\n\n\nFor our analysis, we aimed to examine key indicators that could influence a commuter’s mode choice. We first compared the total population and total number of workers in each census tract to identify where work-based trips are most likely to be generated. The two graphs show a strong correlation, indicating that areas with larger populations also tend to have a higher number of workers.\nIn 2023, the median household income in Philadelphia was $60,698, adjusted for inflation. However, when visualizing the data on the map, income disparities become apparent. High-income areas are concentrated in the Northwest and South, while the West, North, and Northeast regions fall below the median income threshold, highlighting areas of economic inequality.\nWe explored travel time across different census tracts to identify areas with greater mobility challenges. As expected, regions farther from Center City experience longer travel times. However, it is noteworthy that travel times for residents in North Philly and Lower West Philly are higher than those in other nearby areas, despite their proximity to the city center.\nOur map also reveals several key correlations. Areas with a majority of Black households tend to have a higher proportion of households without vehicles. Additionally, these areas generally exhibit lower median incomes, further indicating socioeconomic disparities that influence transportation needs and mode choice across the city.\n\n\nCode\n# Convert object columns to numeric, coercing errors into NaN (missing data)\ncols_to_convert = ['Median_Income', 'Total_Population', 'Total_Workers', 'White_Alone', 'Black_Alone',\n                   'Mean_travel_time', 'No_vehicles', 'One_vehicle', 'Two_vehicles', \n                   'Three_vehicles', 'Four_or_more_vehicles']\n\nfor col in cols_to_convert:\n    acs_data[col] = pd.to_numeric(acs_data[col], errors='coerce')\n    \n# Calculate the share of each race relative to the total population\nacs_data['White_Share'] = acs_data['White_Alone'] / acs_data['Total_Population']\nacs_data['Black_Share'] = acs_data['Black_Alone'] / acs_data['Total_Population']\n\n# Assign the race with the highest share\nacs_data['race_majority'] = acs_data[['White_Share', 'Black_Share']].idxmax(axis=1)\n\n# Clean data\nacs_data = acs_data[acs_data['Median_Income'] != -666666666]\n\n# Calculate Mean travel time in minutes\nacs_data['Average_travel_time'] = (acs_data['Mean_travel_time'] / acs_data['Total_Workers']).fillna(0).apply(lambda x: max(x, 0))\nacs_data['Average_travel_time'] = acs_data['Average_travel_time'].round(0).astype(int)\n\n\nC:\\Users\\USER\\miniforge3\\envs\\musa-550-fall-2023\\lib\\site-packages\\geopandas\\geodataframe.py:1538: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n\n\n\n\nCode\n# Create a list of the columns to plot\ncolumns_to_plot = ['Total_Population', 'Total_Workers', 'Median_Income','Average_travel_time', 'No_vehicles', 'race_majority']\n\n# Set up a grid of subplots\nfig, axes = plt.subplots(3, 2, figsize=(8, 6)) \naxes = axes.flatten() \n\n# Loop through the columns to plot each one\nfor i, column in enumerate(columns_to_plot):\n    ax = axes[i]\n    acs_data.plot(column=column, ax=ax, legend=True, cmap='Blues')\n    ax.set_title(f\"{column}\")\n    ax.set_axis_off()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nWhile researching a transit rider vulnerability matrix, we consistently found that exposure to heat was a critical factor. However, vulnerability to heat is closely correlated with several other variables, many of which we have already explored. As a result, we decided to incorporate the City’s Heat Vulnerability Index (HVI) to highlight areas most at risk of experiencing heat-related illness.\nThe Philadelphia Heat Vulnerability Index (HVI) captures key factors that contribute to the negative health effects of extreme heat events. The HVI rating is calculated by combining both exposure and sensitivity indicators:\n\nAge: The percentage of the population over 65 years old, as older individuals are more susceptible to heat-related illnesses.\nEducational Attainment: The percentage of individuals over 25 years old without a high school diploma, which can be linked to lower awareness of heat risks.\nLanguage Barrier: The percentage of limited English-speaking households, which can affect the ability to receive heat-related warnings and information.\nLow Socioeconomic Status: The percentage of the population living below the Federal Poverty Level, as economically disadvantaged individuals may have fewer resources to adapt to extreme heat.\nRace & Ethnicity: The percentage of the population identifying as non-white, as certain racial and ethnic groups may experience heightened vulnerability due to social and economic factors.\nSocial Isolation: The percentage of the population over 65 years old living alone, as socially isolated individuals may lack support during heat events.\nHealth Status: This factor considers the underlying health conditions that may exacerbate the effects of extreme heat, such as chronic diseases or disabilities that limit mobility or access to cooling resources.\n\n\n\nCode\nheat = pd.read_csv('data\\heat_vulnerability_ct.csv')\nheat.rename(columns={'geoid10': 'GEOID'}, inplace=True)\n\n# Merge the heat vulnerability data with acs data\nheat['GEOID'] = heat['GEOID'].astype(str)\nacs_data_index = acs_data.merge(heat, on='GEOID')\n\n# List of the columns to plot\ncolumns_to_plot = ['hsi_score','hei_score', 'hvi_score', 'n_veryhigh']\n\nfig, axes = plt.subplots(2, 2, figsize=(8, 6))\naxes = axes.flatten() \n\n# Loop through the columns and plot each one\nfor i, column in enumerate(columns_to_plot):\n    ax = axes[i]\n    acs_data_index.plot(column=column, ax=ax, legend=True, cmap='Blues')\n    ax.set_title(f\"{column}\")\n    ax.set_axis_off()  \nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nThe City’s Heat Vulnerability Index (HVI) incorporates several socio-demographic parameters to assess vulnerability, and for our Transit Vulnerability Index (TVI), we have integrated these factors with transit-specific parameters, such as travel time and lack of available household vehicles. However, by focusing solely on these three factors, we may overlook households that, although located far from transit routes and reliant on personal vehicles for commuting, still experience economic disadvantage. To address this gap, we reintroduced the income variable to better account for such populations.\nGiven that this assessment is focused primarily on transit, we assigned a value of 1 to both median income and HVI, and a value of 2 to commute time and access to vehicles, reflecting their relative importance in influencing transit vulnerability. Our final TVI, ranging from 0 to 6, provides a comprehensive vulnerability score for census tracts across Philadelphia. Notably, the map below highlights North Philadelphia, particularly Strawberry Mansion, and West Philadelphia, specifically Cobbs Creek, as areas where transit riders are particularly vulnerable.\n\n\nCode\n# Social Vulnerability Index (SVI)\n\nhighest_quartile_travel_time = acs_data_index['Average_travel_time'].quantile(0.75)\nhighest_quartile_no_vehicles = acs_data_index['No_vehicles'].quantile(0.75)\nlowest_quartile_median_income = acs_data_index['Median_Income'].quantile(0.25)\n\nacs_data_index['Social_Vulnerability_Index'] = 0\n\n# Assign points\nacs_data_index.loc[acs_data_index['n_veryhigh'] == 1, 'Social_Vulnerability_Index'] += 1\nacs_data_index.loc[acs_data_index['Median_Income'] &lt;= lowest_quartile_median_income, 'Social_Vulnerability_Index'] += 1\nacs_data_index.loc[acs_data_index['Average_travel_time'] &gt;= highest_quartile_travel_time, 'Social_Vulnerability_Index'] += 2\nacs_data_index.loc[acs_data_index['No_vehicles'] &gt;= highest_quartile_no_vehicles, 'Social_Vulnerability_Index'] += 2\nacs_data_index[['n_veryhigh', 'Average_travel_time', 'No_vehicles', 'Median_Income','Social_Vulnerability_Index']].head()\n\n# Create the first map plot (Choropleth map)\nmap_plot = alt.Chart(acs_data_index).mark_geoshape().encode(\n    color=alt.Color('Social_Vulnerability_Index:Q', scale=alt.Scale(scheme='blues')),\n    tooltip=['GEOID:N', 'n_veryhigh:Q', 'Average_travel_time:Q', 'No_vehicles:Q', 'Median_Income:Q','race_majority:N']\n).add_params(brush).properties(\n    width=500,\n    height=500)\n\nchart = alt.vconcat(map_plot)\nchart"
  },
  {
    "objectID": "GTFS.html",
    "href": "GTFS.html",
    "title": "Mapping Transit Network",
    "section": "",
    "text": "#Load Packages:\n\nimport os\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport geopandas as gpd\nimport osmnx as ox\nimport shapely\nfrom shapely.geometry import Point\nimport folium\nfrom folium import Choropleth"
  },
  {
    "objectID": "GTFS.html#create-philadelphias-bus-network",
    "href": "GTFS.html#create-philadelphias-bus-network",
    "title": "Mapping Transit Network",
    "section": "Create Philadelphia’s Bus Network:",
    "text": "Create Philadelphia’s Bus Network:\nConvert all shapes from points to linestrings:\n\nprint(shapes_df)\n\n        shape_id  shape_pt_lat  shape_pt_lon  shape_pt_sequence\n0         286406     39.976568    -75.196097                206\n1         286406     40.006143    -75.196839                417\n2         286406     40.006429    -75.197471                420\n3         286410     39.985246    -75.208209                294\n4         286410     39.986857    -75.207831                307\n...          ...           ...           ...                ...\n536088    286742     39.945364    -75.326472                440\n536089    286753     39.918701    -75.264710                178\n536090    286659     39.949104    -75.275955                152\n536091    286660     39.960680    -75.349991                142\n536092    286661     39.950913    -75.267558                125\n\n[536093 rows x 4 columns]\n\n\n\nfrom shapely.geometry import LineString\n\n# Ensure the DataFrame is sorted by shape_id and shape_pt_sequence\nshapes_df = shapes_df.sort_values(by=['shape_id', 'shape_pt_sequence'])\n\n# Group by shape_id and create LineString for each group\nlines = (\n    shapes_df.groupby('shape_id')\n    .apply(lambda group: LineString(zip(group['shape_pt_lon'], group['shape_pt_lat'])))\n    .reset_index(name='geometry')\n)\n\n# Create a GeoDataFrame from the lines\nbus_network = gpd.GeoDataFrame(lines, geometry='geometry', crs='EPSG:4326')\n\nbus_network.plot()\n\n\n\n\n\n\n\n\n\nTrim Bus Network to Philadelphia City Boundary\nAdd city boundary:\n\ncity_boundary = ox.geocode_to_gdf(\"Philadelphia, Pennsylvania, USA\")\n\ncity_boundary.plot()\n\n\n\n\n\n\n\n\nTrim bus network:\n\n# Clip the shapes to the Philadelphia boundary\nbus_network_philadelphia = gpd.clip(bus_network, city_boundary)\n\nbus_network_philadelphia.plot()\n\n\n\n\n\n\n\n\nAt this step, we ensure that our segment data is working as desired so that it can combine with our points data.\n\nfrom shapely.geometry import Point, LineString, MultiLineString\n\n# Function to convert MultiLineString to LineString\ndef convert_to_linestring(geometry):\n    if isinstance(geometry, MultiLineString):\n        # Combine all components into a single LineString\n        combined_coords = []\n        for line in geometry.geoms:  # Use .geoms to iterate over the components\n            combined_coords.extend(line.coords)\n        return LineString(combined_coords)\n    return geometry  # If already a LineString, return as is\n\n# Apply the conversion function to the GeoDataFrame\nbus_network_philadelphia['geometry'] = bus_network_philadelphia['geometry'].apply(convert_to_linestring)\n\n\n\nimport networkx as nx\nfrom shapely.ops import split, unary_union\n\n# Create a graph from the GeoDataFrame\ndef geodataframe_to_graph(gdf):\n    G = nx.Graph()\n    for line in gdf.geometry:\n        if isinstance(line, LineString):\n            coords = list(line.coords)\n            for i in range(len(coords) - 1):\n                G.add_edge(Point(coords[i]), Point(coords[i + 1]), geometry=LineString(coords[i:i + 2]))\n    return G\n\n# Convert GeoDataFrame to a graph\ngraph = geodataframe_to_graph(bus_network_philadelphia)\n\n# Split the network into edges divided by nodes\nedges = []\nfor edge in graph.edges(data=True):\n    line = edge[2]['geometry']\n    start_node = edge[0]\n    end_node = edge[1]\n    edges.append({\n        'geometry': line,\n        'start': start_node,\n        'end': end_node\n    })\n\n# Create a GeoDataFrame of edges\nedges_gdf = gpd.GeoDataFrame(edges, crs=bus_network_philadelphia.crs)\n\nedges_gdf = gpd.clip(edges_gdf, city_boundary)\n\nedges_gdf.plot()\n\n\n\n\n\n\n\n\n\n\nTotal daily buses arriving at each bus stop:\nBy aggregating this data, we estimated the daily arrivals at each bus stop, effectively quantifying the daily traffic across the network. The distribution, as illustrated in the bar plot below, reveals that while a small number of stops experience exceptionally high traffic exceeding 2,000 buses per day (likely transit interchange hubs), the majority of bus stops accommodate approximately 183 buses daily.\n\ndaily_buses = stop_times_df.groupby([\"stop_id\"]).size().reset_index(name=\"daily_arrivals\")\n\ndaily_buses_sorted = daily_buses.sort_values(by=\"daily_arrivals\", ascending=False).reset_index(drop=True)\n\ndaily_buses_sorted.head()\n\n\n\n\n\n\n\n\nstop_id\ndaily_arrivals\n\n\n\n\n0\n283\n3876\n\n\n1\n593\n2592\n\n\n2\n21204\n2323\n\n\n3\n10266\n2252\n\n\n4\n1148\n2219\n\n\n\n\n\n\n\n\nplt.figure(figsize=(8, 6))\n\n# Create the histogram with bins in intervals of 400\nplt.hist(\n    daily_buses[\"daily_arrivals\"],\n    bins=range(0, daily_buses[\"daily_arrivals\"].max() + 100, 100),  # Adjust bins\n    edgecolor=\"black\",\n    align=\"left\"\n)\n\n# Set titles and labels\nplt.title(\"Distribution of Bus Stops by Total Daily Bus Arrivals\", fontsize=16)\nplt.xlabel(\"Number of Daily Bus Arrivals\", fontsize=12)\nplt.ylabel(\"Number of Bus Stops\", fontsize=12)\n\n# Set x-ticks to match the bin intervals\nplt.xticks(range(0, daily_buses[\"daily_arrivals\"].max() + 400, 400))\n\n# Add a grid for better readability\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)\n\n# Display the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\nTotal Number and Peak Period\nThe data was subsequently grouped by each hour of the day to analyze the temporal distribution of bus service. The bar chart below illustrates the hourly distribution, revealing two distinct periods of heightened bus frequency: between 7 AM and 8 AM, and from 3 PM to 6 PM, with consistently elevated service levels during the midday hours. Bus frequency gradually declines after 8 PM until 5 AM. For the purpose of this analysis, the 3 PM to 6 PM window is designated as the peak period due to its sustained high frequency and significance in transit operations.\n\nstop_times_df[\"hour\"] = stop_times_df[\"arrival_time\"].str.slice(0, 2).astype(int)\n\n# Group by trip_id and hour, and count rows\nhourly_bus_arrivals = stop_times_df.groupby([\"stop_id\", \"hour\"]).size().reset_index(name=\"hourly_arrivals\")\n\nhourly_bus_arrivals_sorted = hourly_bus_arrivals.sort_values(by=\"hourly_arrivals\", ascending=False).reset_index(drop=True)\n\nhourly_bus_arrivals_sorted.head()\n\n\n\n\n\n\n\n\nstop_id\nhour\nhourly_arrivals\n\n\n\n\n0\n283\n16\n287\n\n\n1\n283\n17\n278\n\n\n2\n283\n8\n273\n\n\n3\n283\n15\n266\n\n\n4\n283\n7\n232\n\n\n\n\n\n\n\n\n\nFind number of buses per hour on the entire system to determine peak period:\n\ntotal_hourly_buses = stop_times_df.groupby([\"hour\"]).size().reset_index(name=\"total_bus_arrivals\")\n\ntotal_hourly_buses = total_hourly_buses[total_hourly_buses[\"hour\"] &lt;= 24]\n\ntotal_hourly_buses = total_hourly_buses.sort_values(by=\"total_bus_arrivals\", ascending=False).reset_index(drop=True)\n\ntotal_hourly_buses.head()\n\n\n\n\n\n\n\n\nhour\ntotal_bus_arrivals\n\n\n\n\n0\n16\n188679\n\n\n1\n15\n187335\n\n\n2\n17\n184023\n\n\n3\n7\n177282\n\n\n4\n8\n176510\n\n\n\n\n\n\n\n\n\nFind Peak Period\n\nplt.figure(figsize=(10, 6))\nplt.bar(total_hourly_buses[\"hour\"], total_hourly_buses[\"total_bus_arrivals\"], edgecolor=\"black\")\n\n# Add labels and title\nplt.title(\"Total Bus Arrivals by Hour\", fontsize=16)\nplt.xlabel(\"Hour\", fontsize=12)\nplt.ylabel(\"Total Daily Bus Arrivals\", fontsize=12)\nplt.xticks(total_hourly_buses[\"hour\"])  # Ensure x-axis ticks align with hours\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\nBus Frequency\nIn transit planning, frequency refers to the number of buses servicing a particular stop within a given time frame, typically measured as buses per hour. It is a critical metric for understanding the level of service provided by a transit network, as higher frequency generally translates to shorter wait times for passengers and improved overall service reliability. In this analysis, frequency is calculated by determining the number of bus arrivals at each stop during specified time periods (3 PM to 6 PM).\n\npeak_bus_arrivals = hourly_bus_arrivals[hourly_bus_arrivals[\"hour\"].isin([3, 4, 5])]\n\npeak_frequency = peak_bus_arrivals.groupby(\"stop_id\", as_index=False)[\"hourly_arrivals\"].sum()\n\npeak_frequency = peak_frequency.rename(columns={\"hourly_arrivals\": \"bus_arrivals\"})\n\n# Create a new column 'frequency'\npeak_frequency[\"frequency\"] = peak_frequency[\"bus_arrivals\"] / 3\n\npeak_frequency.head()\n\n\n\n\n\n\n\n\nstop_id\nbus_arrivals\nfrequency\n\n\n\n\n0\n2\n23\n7.666667\n\n\n1\n4\n46\n15.333333\n\n\n2\n5\n37\n12.333333\n\n\n3\n7\n6\n2.000000\n\n\n4\n8\n66\n22.000000\n\n\n\n\n\n\n\nNote: Frequency is the number of buses per hour at a bus stop\n\n\nBus Headways\nAdditionally, headways—the time interval between consecutive buses at a stop—are directly derived from frequency. It directly impacts passenger experience, as shorter headways result in reduced waiting times and greater convenience, particularly during peak periods when demand is highest. Here, we first calculate the number of bus arrivals at a stop during peak period. After getting the per hour frequency, we calculate the headway at a bus stop by dividing 60 minutes. On an average the headway is 30 minutes.\n\n# Calculate the headway and assign it to a new column\npeak_frequency[\"headway\"] = 60 / peak_frequency[\"frequency\"]\n\npeak_frequency = peak_frequency.sort_values(by=\"headway\", ascending=True).reset_index(drop=True)\n\n# Display the updated DataFrame\nprint(peak_frequency)\n\n      stop_id  bus_arrivals  frequency     headway\n0       10266           231  77.000000    0.779221\n1         283           194  64.666667    0.927835\n2        1148           176  58.666667    1.022727\n3       31564           166  55.333333    1.084337\n4         341           111  37.000000    1.621622\n...       ...           ...        ...         ...\n9981    27732             1   0.333333  180.000000\n9982    22380             1   0.333333  180.000000\n9983    22370             1   0.333333  180.000000\n9984    22388             1   0.333333  180.000000\n9985    18183             1   0.333333  180.000000\n\n[9986 rows x 4 columns]\n\n\nNote: Headway refers to number of minutes in between bus arrivals\n\n\nMerge calculated bus metrics with the stops dataframe containing stop names and co-ordinates:\n\npeak_metrics = pd.merge(peak_frequency, stops_df, on=\"stop_id\", how=\"inner\")\n\npeak_metrics.head()\n\n\n\n\n\n\n\n\nstop_id\nbus_arrivals\nfrequency\nheadway\nstop_name\nstop_lat\nstop_lon\nlocation_type\nparent_station\nzone_id\nwheelchair_boarding\n\n\n\n\n0\n10266\n231\n77.000000\n0.779221\nMarket St & 15th St\n39.952547\n-75.165475\nNaN\nNaN\n1\n1\n\n\n1\n283\n194\n64.666667\n0.927835\n13th St\n39.952532\n-75.162559\nNaN\nNaN\n1\n2\n\n\n2\n1148\n176\n58.666667\n1.022727\n69th St Transportation Center South Terminal\n39.962079\n-75.258284\nNaN\n31034.0\n1\n1\n\n\n3\n31564\n166\n55.333333\n1.084337\n15th St & Market St - FS\n39.952493\n-75.165393\nNaN\nNaN\n1\n1\n\n\n4\n341\n111\n37.000000\n1.621622\nRichmond St & Westmoreland St Loop\n39.984253\n-75.099553\nNaN\nNaN\n1\n1\n\n\n\n\n\n\n\n\n\nBus Ridership:\nWe then merge the ridership at each stop to our existing dataset containing frequency and headway.\n\nridership = pd.read_csv(\"Data/Fall_2023_Stop_Summary_(Bus).csv\")\n\nridership[\"Ridership\"] = ridership[\"Weekday_On\"] + ridership[\"Weekday_Of\"]\n\nridership.rename(columns={\"Stop_Code\": \"stop_id\"}, inplace=True)\n\nridership_by_stop = ridership.groupby(\"stop_id\")[\"Ridership\"].sum().reset_index()\n\nridership_by_stop.head()\n\n\n\n\n\n\n\n\nstop_id\nRidership\n\n\n\n\n0\n2\n1188\n\n\n1\n4\n666\n\n\n2\n5\n448\n\n\n3\n7\n41\n\n\n4\n8\n1280\n\n\n\n\n\n\n\n\n#Merge Ridership and Schedules\n\npeak_metrics = pd.merge(peak_metrics, ridership_by_stop, on=\"stop_id\", how=\"inner\")\n\nprint(peak_metrics)\n\n      stop_id  bus_arrivals  frequency     headway  \\\n0       10266           231  77.000000    0.779221   \n1        1148           176  58.666667    1.022727   \n2       31564           166  55.333333    1.084337   \n3         341           111  37.000000    1.621622   \n4         841           103  34.333333    1.747573   \n...       ...           ...        ...         ...   \n9140    27732             1   0.333333  180.000000   \n9141    22380             1   0.333333  180.000000   \n9142    22370             1   0.333333  180.000000   \n9143    22388             1   0.333333  180.000000   \n9144    18183             1   0.333333  180.000000   \n\n                                         stop_name   stop_lat   stop_lon  \\\n0                              Market St & 15th St  39.952547 -75.165475   \n1     69th St Transportation Center South Terminal  39.962079 -75.258284   \n2                         15th St & Market St - FS  39.952493 -75.165393   \n3               Richmond St & Westmoreland St Loop  39.984253 -75.099553   \n4                  Fern Rock Transportation Center  40.041940 -75.136970   \n...                                            ...        ...        ...   \n9140                State Rd & Pennypack St - MBFS  40.043558 -74.998562   \n9141                Bustleton Av & Scotchbrook Dr   40.082637 -75.040538   \n9142                        Welsh Rd & Michael Rd   40.063238 -75.028130   \n9143                      Alburger Av & Verree Rd   40.094735 -75.050601   \n9144                    Washington Ln & Chew -MBNS  40.051825 -75.172181   \n\n      location_type  parent_station  zone_id  wheelchair_boarding  Ridership  \n0               NaN             NaN        1                    1       2848  \n1               NaN         31034.0        1                    1       4758  \n2               NaN             NaN        1                    1        539  \n3               NaN             NaN        1                    1        222  \n4               NaN             NaN        1                    1       1509  \n...             ...             ...      ...                  ...        ...  \n9140            NaN             NaN        1                    1          0  \n9141            NaN             NaN        1                    1          2  \n9142            NaN             NaN        1                    1         14  \n9143            NaN             NaN        1                    1         16  \n9144            NaN             NaN        1                    1         12  \n\n[9145 rows x 12 columns]\n\n\nOur analysis aimed to determine whether higher frequency (or shorter headways) correlates with greater ridership. While ridership and frequency exhibit a positive correlation, the presence of many outliers highlights the need for a combined analysis of both variables. This is crucial for identifying streets that would benefit most from improvements such as bus lanes, and it suggests that increasing frequency may be necessary to better accommodate the current ridership levels.\n\nimport numpy as np\n\n# Ensure data is numeric and drop rows with NaN values for the columns of interest\npeak_metrics_cleaned = peak_metrics.dropna(subset=['frequency', 'Ridership'])\n\n# Extract the data\nx = peak_metrics_cleaned['frequency']\ny = peak_metrics_cleaned['Ridership']\n\n# Fit a linear regression model\ncoefficients = np.polyfit(x, y, 1)  # Degree 1 for linear regression\ntrendline = np.poly1d(coefficients)\n\n# Create the scatterplot\nplt.figure(figsize=(8, 6))\nplt.scatter(x, y, alpha=0.7, label='Data')\n\n# Add the trend line\nplt.plot(x, trendline(x), color='red', linestyle='--', label='Trend Line')\n\n# Add titles and labels\nplt.title('Scatterplot of Frequency vs Ridership with Trend Line', fontsize=16)\nplt.xlabel('Frequency', fontsize=12)\nplt.ylabel('Ridership', fontsize=12)\n\n# Add legend\nplt.legend()\n\n# Show grid\nplt.grid(True, linestyle='--', alpha=0.5)\n\n# Display the plot\nplt.show()\n\n\n\n\n\n\n\n\nThis presumption is supported by the scatter-plot below, which reveals that stops with extremely high ridership are concentrated near the origin, corresponding to headways of under 25 minutes. We can also see that areas with greater headways have their ridership closer to origin well- suggesting lower ridership demand.\n\n# Scatterplot: Ridership vs. Headway\nplt.figure(figsize=(8, 6))\n\nplt.scatter(\n    peak_metrics[\"headway\"],\n    peak_metrics[\"Ridership\"],\n    c=\"blue\",\n    alpha=0.4,)\n\nplt.title(\"Scatterplot: Ridership vs. Headway\", fontsize=16)\nplt.xlabel(\"Headway (minutes)\", fontsize=12)\nplt.ylabel(\"Ridership\", fontsize=12)\nplt.grid(alpha=0.3)\nplt.tight_layout()\nplt.show()\n\n\n\nConvert Bus Data to GeoDataframe\n\ngeometry = [Point(xy) for xy in zip(peak_metrics[\"stop_lon\"], peak_metrics[\"stop_lat\"])]\npeak_metrics_geo = gpd.GeoDataFrame(peak_metrics, geometry=geometry)\n\n# Set a Coordinate Reference System (CRS)\npeak_metrics_geo.set_crs(epsg=4326, inplace=True)  # WGS84 CRS\n\npeak_metrics_geo.head()\n\n\n\n\n\n\n\n\nstop_id\nbus_arrivals\nfrequency\nheadway\nstop_name\nstop_lat\nstop_lon\nlocation_type\nparent_station\nzone_id\nwheelchair_boarding\nRidership\ngeometry\n\n\n\n\n0\n10266\n231\n77.000000\n0.779221\nMarket St & 15th St\n39.952547\n-75.165475\nNaN\nNaN\n1\n1\n2848\nPOINT (-75.16548 39.95255)\n\n\n1\n1148\n176\n58.666667\n1.022727\n69th St Transportation Center South Terminal\n39.962079\n-75.258284\nNaN\n31034.0\n1\n1\n4758\nPOINT (-75.25828 39.96208)\n\n\n2\n31564\n166\n55.333333\n1.084337\n15th St & Market St - FS\n39.952493\n-75.165393\nNaN\nNaN\n1\n1\n539\nPOINT (-75.16539 39.95249)\n\n\n3\n341\n111\n37.000000\n1.621622\nRichmond St & Westmoreland St Loop\n39.984253\n-75.099553\nNaN\nNaN\n1\n1\n222\nPOINT (-75.09955 39.98425)\n\n\n4\n841\n103\n34.333333\n1.747573\nFern Rock Transportation Center\n40.041940\n-75.136970\nNaN\nNaN\n1\n1\n1509\nPOINT (-75.13697 40.04194)\n\n\n\n\n\n\n\n\npeak_metrics_geo.plot()\n\n\n\n\n\n\n\n\nTo focus on bus stops within the city limits, we restrict the data to those located inside the city boundary:\n\npeak_metrics_geo = gpd.clip(peak_metrics_geo, city_boundary)\n\n\npeak_metrics_geo.plot()"
  },
  {
    "objectID": "GTFS.html#level-of-service-analysis",
    "href": "GTFS.html#level-of-service-analysis",
    "title": "Mapping Transit Network",
    "section": "Level of Service Analysis",
    "text": "Level of Service Analysis\nTo better understand the spatial distribution of bus network, we first clipped the network to city limits."
  },
  {
    "objectID": "GTFS.html#visualise-metrics-by-bus-stop",
    "href": "GTFS.html#visualise-metrics-by-bus-stop",
    "title": "Mapping Transit Network",
    "section": "Visualise metrics by bus stop:",
    "text": "Visualise metrics by bus stop:\nTo evaluate the level of service across Philadelphia and understand user patterns, we visualized three key components—frequency, headway, and ridership—on a map for peak periods. The map reveals that most areas in the city benefit from frequent bus services, with frequency under 10 during peak times and averaging below 20 minutes headway across the day. However, there are extreme outliers in some regions, where headway exceed 180 minutes, highlighting disparities in service provision. By adding a geographic component, we observe a more nuanced distribution of ridership across Philadelphia. As expected, areas in Center City exhibit high ridership and frequent bus service. Conversely, far-flung areas such as Upper Northwest and Lower Northwest show lower ridership levels and greater headway. Interestingly, Lower Northeast stands out with the highest ridership of all districts.\nInterestingly, while frequency and headway vary significantly across the city, ridership appears more evenly distributed, with notable exceptions in Center City, which experiences concentrated high ridership, and the Lower Northwest, near Mt. Airy, which shows higher ridership despite longer headway.\n\nimport ipywidgets as widgets\n\n# create function\ndef create_map(selected_metric):\n    fig, ax = plt.subplots(figsize=(8, 8))\n    peak_metrics_geo.plot(\n        ax=ax,\n        column=selected_metric, \n        cmap=\"plasma\",            \n        legend=True,              \n        markersize=2)\n    \n    \n    plt.title(f\"{selected_metric.capitalize()} by Bus Stop\", fontsize=16)\n    plt.xlabel(\"Longitude\")\n    plt.ylabel(\"Latitude\")\n    plt.show()\n\ndropdown = widgets.Dropdown(\n    options=['frequency', 'headway', 'Ridership'],  \n    value='frequency',\n    description='Metric:',)\n\nwidgets.interactive(create_map, selected_metric=dropdown)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nFile ~\\miniforge3\\envs\\musa-550-fall-2023\\lib\\site-packages\\ipywidgets\\widgets\\interaction.py:243, in interactive.update(self, *args)\n    241     value = widget.get_interact_value()\n    242     self.kwargs[widget._kwarg] = value\n--&gt; 243 self.result = self.f(**self.kwargs)\n    244 show_inline_matplotlib_plots()\n    245 if self.auto_display and self.result is not None:\n\nCell In[1], line 5, in create_map(selected_metric)\n      4 def create_map(selected_metric):\n----&gt; 5     fig, ax = plt.subplots(figsize=(8, 8))\n      6     peak_metrics_geo.plot(\n      7         ax=ax,\n      8         column=selected_metric, \n      9         cmap=\"plasma\",            \n     10         legend=True,              \n     11         markersize=2)\n     14     plt.title(f\"{selected_metric.capitalize()} by Bus Stop\", fontsize=16)\n\nNameError: name 'plt' is not defined"
  },
  {
    "objectID": "GTFS.html#visualisation-of-metrics-by-street-segments-on-philadelphias-bus-network",
    "href": "GTFS.html#visualisation-of-metrics-by-street-segments-on-philadelphias-bus-network",
    "title": "Mapping Transit Network",
    "section": "Visualisation of Metrics by Street Segments on Philadelphia’s Bus Network",
    "text": "Visualisation of Metrics by Street Segments on Philadelphia’s Bus Network\nFollowing the spatial join, we can now analyze bus headways during peak hours by street segments, providing a more refined view of service levels across different parts of the city. Major corridors in Philadelphia, such as Broad Street, Walnut Street, Chestnut Street, Market Street, and Roosevelt Boulevard, exhibit headways of under 20 minutes, reflecting frequent service. In contrast, streets on the city’s periphery have significantly longer headways, exceeding 120 minutes, highlighting areas with less frequent service.\n\nfig, ax = plt.subplots(figsize=(10, 8))\npeak_metrics_network.plot(\n    ax=ax,\n    column=\"headway\",  # Color by buses_count\n    cmap=\"plasma\",        # Use a colormap (e.g., viridis, plasma, etc.)\n    legend=True,           # Add a legend\n    markersize=1         # Adjust marker size\n)\n\n# Add titles and labels\nplt.title(\"Headway by Street Segment\", fontsize=16)\nplt.xlabel(\"Longitude\")\nplt.ylabel(\"Latitude\")\n\nText(110.89550110614813, 0.5, 'Latitude')\n\n\n\n\n\n\n\n\n\nWhen examining ridership by street segments, the distribution tells a different story. Ridership remains relatively consistent across most of the network, regardless of the headway. However, ridership spikes above 2,000 passengers for specific routes around Mt. Airy, Frankford, N Broad St., as well as Center City. These areas, particularly in the North, host major transportation hubs that attract a high volume of trips.\n\nfig, ax = plt.subplots(figsize=(10, 8))\npeak_metrics_network.plot(\n    ax=ax,\n    column=\"Ridership\",  # Color by buses_count\n    cmap=\"plasma\",        # Use a colormap (e.g., viridis, plasma, etc.)\n    legend=True,           # Add a legend\n    markersize=1         # Adjust marker size\n)\n\n# Add titles and labels\nplt.title(\"Ridership by Street Segment\", fontsize=16)\nplt.xlabel(\"Longitude\")\nplt.ylabel(\"Latitude\")\n\nText(110.89550110614813, 0.5, 'Latitude')\n\n\n\n\n\n\n\n\n\n\npeak_metrics_network = peak_metrics_network.drop(columns=['start', 'end'], errors='ignore')  # Replace 'start', 'end' with problematic columns\n\npeak_metrics_network.to_file(\"Data/peak_metrics_network.geojson\", driver=\"GeoJSON\")"
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "This research utilizes a combination of ridership data, bus operational performance metrics, and demographic datasets to identify key areas for impactful transit solutions in Philadelphia.\nSEPTA GTFS API The General Transit Feed Specification (GTFS) API provides standardized transit data, including schedules, routes, stops, and fare information for SEPTA buses, enabling detailed analysis of transit operations.\nOSM Street Network: OpenStreetMap (OSM) data accessed through the osmnx Python package enables the extraction of street networks in Philadelphia.\nSEPTA Ridership Data: SEPTA’s ridership statistics provide insights into the number of passengers using different bus routes, helping identify high-demand corridors.\nHeat Vulnerability Data: The Heat Vulnerability dataset highlights areas in Philadelphia most at risk during extreme heat events. It integrates social and environmental factors to pinpoint vulnerable populations.\nCensus API/ACS: The American Community Survey (ACS) API provides demographic data at various geographic levels to help analyze population characteristics such as income, age, and vehicle ownership.\nDVRPC/AADT: The Delaware Valley Regional Planning Commission (DVRPC) provides Annual Average Daily Traffic (AADT) data, which includes traffic count locations across the Philadelphia region.\nPhiladelphia Vision Zero High Injury Network: This dataset outlines the high-injury network in Philadelphia, identifying locations with the highest frequency of traffic-related injuries and fatalities."
  }
]